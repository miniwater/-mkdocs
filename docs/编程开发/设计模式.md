# 设计模式

## 创建型模式（Creational）

关注对象的实例化过程，包括了如何实例化对象、隐藏对象的创建细节等。

### 单例模式（Singleton Pattern）

确保一个类只有一个实例，并提供该实例的全局访问点。

> 数据库类设计，只连接一次数据库，防止打开多个数据库连接

使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。

私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。

```php
class Single {
    private $name;//声明一个私有的实例变量
    private function __construct(){//声明私有构造方法为了防止外部代码使用new来创建对象。
    
    }

    static public $instance;//声明一个静态变量（保存在类中唯一的一个实例）
    static public function getinstance(){//声明一个getinstance()静态方法，用于检测是否有实例对象
        if(!self::$instance) self::$instance = new self();
        return self::$instance;
    }

    public function setname($n){ $this->name = $n; }
    public function getname(){ return $this->name; }
}

$oa = Single::getinstance();
$ob = Single::getinstance();
$oa->setname('hello php world');
$ob->setname('good morning php');
echo $oa->getname();//good morning php
echo $ob->getname();//good morning php
```

### 简单工厂

在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。

简单工厂又叫静态工厂方法模式，简单工厂模式是通过一个静态方法创建对象的。

> 违反开闭原则（对于扩展是开放的，对于修改是关闭的）

新增时需要改动原有类文件，在里面新增方法或判断。

调用时用同一个对象，但用的方法不一样，或传进去的参数不一样。如:

```php
<?php
SimpleFactoty::creatA();
SimpleFactoty::creatB();
SimpleFactoty::creatC();

// or

SimpleFactoty::creat("A");
SimpleFactoty::creat("B");
SimpleFactoty::creat("C");
```

```php
<?php
interface  people
{
    function marry();
}

class man implements people
{
    function marry()
    {
        echo '送玫瑰，送戒指！';
    }
}

class women implements people
{
    function marry()
    {
        echo '穿婚纱！';
    }
}

class SimpleFactoty
{
    // 简单工厂里的静态方法
    static function createMan()
    {
        return new     man;
    }

    static function createWomen()
    {
        return new     women;
    }

}

SimpleFactoty::createMan()->marry();
// 送玫瑰，送戒指！
SimpleFactoty::createWomen()->marry();
// 穿婚纱！
```

> 简单工厂: 调用时`SimpleFactoty`一样，`createMan`方法不一样
> 工厂方法: 调用时`SimpleFactoty`不一样，`createMan`方法一样

### 工厂方法

定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。

> 遵循开闭原则。

新增方法不用改原有类文件，新增文件后继承上游类或接口即可调用。

调用时，对象不一样，但调用方法和返回类型皆为一致。

如：

```php
<?php
FactoryA::create();
FactoryB::create();
FactoryC::create();
?>
```

使用场景：

- 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。
- 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。
- 设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。

在工厂方法中，由子类来创建对象。

```php
<?php
interface  people
{
    function marry();
}

class man implements people
{
    function marry()
    {
        echo '送玫瑰，送戒指！';
    }
}

class women implements people
{
    function marry()
    {
        echo '穿婚纱！';
    }
}

interface  createMan
{  // 注意了，这里是简单工厂本质区别所在，将对象的创建抽象成一个接口。
    function create();
}

class FactoryMan implements createMan
{
    function create()
    {
        return new man;
    }
}

class FactoryWomen implements createMan
{
    function create()
    {
        return new women;
    }
}

FactoryMan::create()->marry();
//送玫瑰，送戒指！
FactoryWomen::create()->marry();
//穿婚纱！
?>
```

> 与简单工厂不同的是前面的`FactoryMan`对象是变化的，`create`方法是固定的。

### 抽象工厂

提供一个接口，用于创建 相关的对象家族 。

抽象工厂模式是工厂模式的一个扩展，如果抽象工厂只有一个产品体系就会退化成工厂模式。属于简单工厂和工厂模式的合体。

> 违反开闭原则

新增时 **可能** 需要改动原有类文件，在里面新增方法或判断。同样要继承上游类或接口。

调用时，对象和调用方法都可不一样。

如：

```php
<?php
FactoryA::create();
FactoryB::change();
FactoryC::change();
FactoryD::delete();
?>
```

体现出了面向接口编程的思想，其实就是用工厂方法生产具有多维度变化的产品类。

缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 工厂里加代码，又要在具体的实现加代码

```php
<?php
interface  people
{
    function marry();
}

class Oman implements people
{
    function marry()
    {
        echo '美女，我送你玫瑰和戒指！';
    }
}

class Iman implements people
{
    function marry()
    {
        echo '我偷偷喜欢你';
    }
}

class Owomen implements people
{
    function marry()
    {
        echo '我要穿婚纱！';
    }
}

class Iwomen implements people
{
    function marry()
    {
        echo '我好害羞哦！！';
    }
}

interface  createMan
{  // 注意了，这里是本质区别所在，将对象的创建抽象成一个接口。
    function createOpen(); //分为 内敛的和外向的

    function createIntro(); //内向
}

class FactoryMan implements createMan
{
    function createOpen()
    {
        return new  Oman;
    }

    function createIntro()
    {
        return new Iman;
    }
}

class FactoryWomen implements createMan
{
    function createOpen()
    {
        return new  Owomen;
    }

    function createIntro()
    {
        return new Iwomen;
    }
}

FactoryMan::createOpen()->marry();  //美女，我送你玫瑰和戒指！
FactoryMan::createIntro()->marry(); //我偷偷喜欢你

FactoryWomen::createOpen()->marry();    //我要穿婚纱！
FactoryWomen::createIntro()->marry();   //我好害羞哦！！
?>
```

### 生成器

封装一个对象的构造过程，并允许按步骤构造。

### 原型模式

使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。
